namespace Papshef2;
public enum ТипЛексемы
{
    Индентификатор,
    Константа,
    Присваивание,
    Разделитель,
    Плюс,
    Минус,
    Умножить,
    ОткрСкобка,
    ЗакрСкобка,
    While,
    Colon,
    Do,
    And,
    Or,
    Сравнение,
    ЗакрФигурСкобка,
    ОткрФигурСкобка,
    Loop,
    Делить
}
public class Парсер
{
    public readonly List<Токен> _токены;
    private int _индексТекущегоТокена;

    public Парсер(List<Токен> токены)
    {
        _токены = токены;
        _индексТекущегоТокена = 0;
    }

    private Токен ТекущийТокен
    {
        get
        {
            if (ЕстьЛиЕщёТокены())
            {
                return _токены[_индексТекущегоТокена];
            }
            else
            {
                throw new Exception("Ошибка: неожиданный конец выражения.");
            }
        }
    }

    private bool ЕстьЛиЕщёТокены()
    {
        return _индексТекущегоТокена < _токены.Count;
    }

    private void Сопоставление(ТипЛексемы ожидаемыйТип)
    {
        if (_индексТекущегоТокена >= _токены.Count)
        {
            throw new Exception($"Ошибка: ожидался {ожидаемыйТип}, но входная строка завершилась. В позиции {_индексТекущегоТокена}");
        }
        if (ТекущийТокен.Тип == ожидаемыйТип)
        {
            _индексТекущегоТокена++;
        }
        else
        {
            throw new Exception($"Ошибка: ожидалось {ожидаемыйТип}, но найдено {ТекущийТокен.Тип}. В позиции {_индексТекущегоТокена}");
        }
    }
    public void Присваивание()
    {
        if (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.Индентификатор)
        {
            Сопоставление(ТипЛексемы.Индентификатор);
            Сопоставление(ТипЛексемы.Присваивание);
            АрифметическоеВыражение();

            if (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.Разделитель)
            {
                Сопоставление(ТипЛексемы.Разделитель);
            }
            else
            {
                throw new Exception($"Ошибка: ожидается ';' в конце выражения. В позиции {_индексТекущегоТокена}");
            }
        }
        else
        {
            throw new Exception($"Ошибка: ожидался идентификатор перед присваиванием. В позиции {_индексТекущегоТокена}");
        }
    }

    private void АрифметическоеВыражение()
    {
        Слагаемое();

        while (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.Плюс || ТекущийТокен.Тип == ТипЛексемы.Минус)
        {
            if (
                ТекущийТокен.Тип == ТипЛексемы.Плюс)
            {
                Сопоставление(ТипЛексемы.Плюс);
            }
            else if (ТекущийТокен.Тип == ТипЛексемы.Минус)
            {
                Сопоставление(ТипЛексемы.Минус);
            }
            Слагаемое();
        }
    }

    private void Слагаемое()
    {
        Фактор();

        while (ТекущийТокен.Тип == ТипЛексемы.Умножить || ТекущийТокен.Тип == ТипЛексемы.Делить)
        {
            if (ТекущийТокен.Тип == ТипЛексемы.Умножить)
            {
                Сопоставление(ТипЛексемы.Умножить);
            }
            else if (ТекущийТокен.Тип == ТипЛексемы.Делить)
            {
                Сопоставление(ТипЛексемы.Делить);
            }

            Фактор();
        }
    }
    private void Фактор()
    {
        if (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.Индентификатор)
        {
            Сопоставление(ТипЛексемы.Индентификатор);
        }else if (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.Константа)
        {
            Сопоставление(ТипЛексемы.Константа);
        }
        else if (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип == ТипЛексемы.ОткрСкобка)
        {
            Сопоставление(ТипЛексемы.ОткрСкобка);
            АрифметическоеВыражение();
            Сопоставление(ТипЛексемы.ЗакрСкобка);
        }
        else
        {
            throw new Exception($"Ошибка: ожидался идентификатор, константа или выражение в скобках. В позиции {_индексТекущегоТокена}");
        }
    }
    private void Условие()
    {
        Сравнение();

        while (ТекущийТокен.Тип == ТипЛексемы.And || ТекущийТокен.Тип == ТипЛексемы.Or)
        {
            if (ТекущийТокен.Тип == ТипЛексемы.And)
            {
                Сопоставление(ТипЛексемы.And);
            }
            else
            {
                Сопоставление(ТипЛексемы.Or);
            }

            Сравнение();
        }
    }

    private void Сравнение()
    {
        Операнд();

        if (ТекущийТокен.Тип == ТипЛексемы.Сравнение)
        {
            Сопоставление(ТипЛексемы.Сравнение);
            Операнд();
        }
    }

    private void Операнд()
    {
        if (ТекущийТокен.Тип == ТипЛексемы.Индентификатор)
        {
            Сопоставление(ТипЛексемы.Индентификатор);
        }
        else if (ТекущийТокен.Тип == ТипЛексемы.Константа)
        {
            Сопоставление(ТипЛексемы.Константа);
        }
        else
        {
            throw new Exception($"Ошибка: ожидался индентификатор или константа. В позиции {_индексТекущегоТокена}");
        }
    }
    public void DoWhile()
    {
        if (ТекущийТокен.Тип == ТипЛексемы.Do)
        {
            Сопоставление(ТипЛексемы.Do);
            Сопоставление(ТипЛексемы.While);

            Условие();

            Оператор();

            Сопоставление(ТипЛексемы.Loop);
        }
        else
        {
            throw new Exception($"Ошибка: ожидался оператор do. В позиции {_индексТекущегоТокена}");
        }
    }
    public void Оператор()
    {
        if (ТекущийТокен.Тип == ТипЛексемы.Индентификатор)
        {
            Присваивание();
        }
        else if (ТекущийТокен.Тип == ТипЛексемы.ОткрФигурСкобка)
        {
            Сопоставление(ТипЛексемы.ОткрФигурСкобка);
            while (ЕстьЛиЕщёТокены() && ТекущийТокен.Тип != ТипЛексемы.ЗакрФигурСкобка)
            {
                Оператор();
            }
            Сопоставление(ТипЛексемы.ЗакрФигурСкобка);
        }
        else
        {
            throw new Exception($"Ошибка: неизвестный оператор {ТекущийТокен.Значение}. В позиции {_индексТекущегоТокена}");
        }
    }
}
public class Токен
{
    public ТипЛексемы Тип { get; }
    public string Значение { get; }

    public Токен(ТипЛексемы тип, string значение)
    {
        Тип = тип;
        Значение = значение;
    }

    public override string ToString()
    {
        return $"{Тип} ({Значение})";
    }
}
public class ЛексическийАнализ
{
    private readonly string _входнаяСтрока;
    private int _позиция;

    public ЛексическийАнализ(string входнаяСтрока)
    {
        _входнаяСтрока = входнаяСтрока.ToLower();
        _позиция = 0;
    }

    public List<Токен> Обозначение()
    {
        var токены = new List<Токен>();

        while (_позиция < _входнаяСтрока.Length)
        {
            var текущийСимвол = _входнаяСтрока[_позиция];

            if (char.IsWhiteSpace(текущийСимвол))
            {
                _позиция++;
                continue;
            }

            if (char.IsLetter(текущийСимвол))
            {
                var индетификатор = ЧтениеИндитификатора();
                if (индетификатор == "do")
                {
                    токены.Add(new Токен(ТипЛексемы.Do, индетификатор));
                }
                else if (индетификатор == "while")
                {
                    токены.Add(new Токен(ТипЛексемы.While, индетификатор));
                }
                else if (индетификатор == "and")
                {
                    токены.Add(new Токен(ТипЛексемы.And, индетификатор));
                }
                else if (индетификатор == "or")
                {
                    токены.Add(new Токен(ТипЛексемы.Or, индетификатор));
                }
                else if (индетификатор == "loop")
                {
                    токены.Add(new Токен(ТипЛексемы.Loop, индетификатор));
                }
                else
                {
                    токены.Add(new Токен(ТипЛексемы.Индентификатор, индетификатор));
                }
                continue;
            }

            if (char.IsDigit(текущийСимвол))
            {
                var число = ЧтениеЧисла();
                токены.Add(new Токен(ТипЛексемы.Константа, число));
                continue;
            }

            switch (текущийСимвол)
            {
                case '=':
                    if (_позиция + 1 < _входнаяСтрока.Length && _входнаяСтрока[_позиция + 1] == '=')
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, "=="));
                        _позиция += 2;
                    }
                    else
                    {
                        токены.Add(new Токен(ТипЛексемы.Присваивание, "="));
                        _позиция++;
                    }
                    break;
                case '!':
                    if (_позиция + 1 < _входнаяСтрока.Length && _входнаяСтрока[_позиция + 1] == '=')
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, "!="));
                        _позиция += 2;
                    }
                    break;
                case '<':
                    if (_позиция + 1 < _входнаяСтрока.Length && _входнаяСтрока[_позиция + 1] == '=')
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, "<="));
                        _позиция += 2;
                    }
                    else
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, "<"));
                        _позиция++;
                    }
                    break;
                case '>':
                    if (_позиция + 1 < _входнаяСтрока.Length && _входнаяСтрока[_позиция + 1] == '=')
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, ">="));
                        _позиция += 2;
                    }
                    else
                    {
                        токены.Add(new Токен(ТипЛексемы.Сравнение, ">"));
                        _позиция++;
                    }
                    break;
                case '+':
                    токены.Add(new Токен(ТипЛексемы.Плюс, "+"));
                    _позиция++;
                    break;
                case '-':
                    токены.Add(new Токен(ТипЛексемы.Минус, "-"));
                    _позиция++;
                    break;
                case '*':
                    токены.Add(new Токен(ТипЛексемы.Умножить, "*"));
                    _позиция++;
                    break;
                case '(':
                    токены.Add(new Токен(ТипЛексемы.ОткрСкобка, "("));
                    _позиция++;
                    break;
                case ')':
                    токены.Add(new Токен(ТипЛексемы.ЗакрСкобка, ")"));
                    _позиция++;
                    break;
                case '{':
                    токены.Add(new Токен(ТипЛексемы.ОткрФигурСкобка, "{"));
                    _позиция++;
                    break;
                case '}':
                    токены.Add(new Токен(ТипЛексемы.ЗакрФигурСкобка, "}"));
                    _позиция++;
                    break;
                case ';':
                    токены.Add(new Токен(ТипЛексемы.Разделитель, ";"));
                    _позиция++;
                    break;
                case '/':
                    токены.Add(new Токен(ТипЛексемы.Делить, "/"));
                    _позиция++;
                    break;
                default:
                    throw new Exception($"Неизвестный символ: {текущийСимвол}");
            }
        }

        return токены;
    }

    private string ЧтениеИндитификатора()
    {
        var начало = _позиция;
        while (_позиция < _входнаяСтрока.Length && char.IsLetterOrDigit(_входнаяСтрока[_позиция]))
        {
            _позиция++;
        }

        return _входнаяСтрока.Substring(начало, _позиция - начало);
    }

    private string ЧтениеЧисла()
    {
        var начало = _позиция;
        while (_позиция < _входнаяСтрока.Length && char.IsDigit(_входнаяСтрока[_позиция]))
        {
            _позиция++;
        }

        return _входнаяСтрока.Substring(начало, _позиция - начало);
    }
}


public class Program
{
    static void Main(string[] args)
    {
        while (true)
        {
            Console.WriteLine("Введите выражение или exit для выхода:");
            string входнаяСтрока = Console.ReadLine();

            if (входнаяСтрока.ToLower() == "exit")
            {
                Console.WriteLine();
                break;
            }
            try
            {
                var ЛексическийАнализатор = new ЛексическийАнализ(входнаяСтрока);
                var токены = ЛексическийАнализатор.Обозначение();

                var парсер = new Парсер(токены);

                парсер.DoWhile();
                Console.WriteLine("Анализ успешно завершен.");
            }
            catch (Exception ex)
            {
                Console.BackgroundColor = ConsoleColor.Red;
                Console.WriteLine(ex.Message);
                Console.ResetColor();
            }
            Console.WriteLine();
        }
    }
}
